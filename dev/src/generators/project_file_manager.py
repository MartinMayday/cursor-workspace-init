"""
Project file manager module.

Creates and updates projectFile.md in project root with codebase analysis results.
"""

import yaml
from pathlib import Path
from typing import Dict, Any, Optional
from datetime import datetime


def create_project_file(context: Dict[str, Any], project_root: Optional[str] = None) -> Path:
    """
    Create or update projectFile.md in project root.
    
    Args:
        context: Context dictionary from codebase analysis
        project_root: Project root directory (default: current directory)
        
    Returns:
        Path to created/updated projectFile.md
    """
    if project_root is None:
        project_root = Path.cwd()
    else:
        project_root = Path(project_root).resolve()
    
    project_file = project_root / 'projectFile.md'
    
    # Prepare project file content
    project_data = {
        'project_name': context.get('project_name', project_root.name),
        'project_type': context.get('project_type', 'unknown'),
        'primary_language': context.get('primary_language', 'unknown'),
        'frameworks': context.get('frameworks', []),
        'languages': context.get('languages', []),
        'technologies': context.get('technologies', 'Unknown'),
        'architecture': context.get('architecture', 'unknown'),
        'deployment_type': context.get('deployment_type', 'unknown'),
        'coding_standards': context.get('coding_standards', {}),
        'file_organization': context.get('file_organization', 'standard'),
        'testing_framework': context.get('testing_framework', 'unknown'),
        'services': context.get('services', []),
        'ports': context.get('ports', []),
        'databases': context.get('databases', []),
        'networking': context.get('networking', {}),
        'project_description': context.get('project_description', ''),
        'project_purpose': context.get('project_purpose', ''),
        'key_concepts': context.get('key_concepts', []),
        'documentation_sources': context.get('documentation_sources', []),
        'containerization': context.get('containerization', []),
        'orchestration': context.get('orchestration', []),
        'cloud_platforms': context.get('cloud_platforms', []),
        'linting_tools': context.get('linting_tools', []),
        'formatting_tools': context.get('formatting_tools', []),
        'build_tools': context.get('build_tools', []),
        'metadata': {
            'created_at': datetime.now().isoformat(),
            'updated_at': datetime.now().isoformat(),
            'version': '1.0.0',
        }
    }
    
    # Write project file as YAML frontmatter + markdown
    content = f"""---
# Project File - Single Source of Truth for Cursor Workspace Configuration
# Generated: {project_data['metadata']['created_at']}
# Updated: {project_data['metadata']['updated_at']}

{yaml.dump(project_data, default_flow_style=False, sort_keys=False, allow_unicode=True)}
---

# Project File

This file serves as the single source of truth for project context used to populate
Cursor workspace templates.

## Project Information

- **Name**: {project_data['project_name']}
- **Type**: {project_data['project_type']}
- **Primary Language**: {project_data['primary_language']}
- **Architecture**: {project_data['architecture']}
- **Deployment**: {project_data['deployment_type']}

## Technology Stack

- **Frameworks**: {', '.join(project_data['frameworks']) if project_data['frameworks'] else 'None'}
- **Languages**: {', '.join(project_data['languages']) if project_data['languages'] else 'None'}
- **Technologies**: {project_data['technologies']}

## Development Tools

- **Testing Framework**: {project_data['testing_framework']}
- **Linting Tools**: {', '.join(project_data['linting_tools']) if project_data['linting_tools'] else 'None'}
- **Formatting Tools**: {', '.join(project_data['formatting_tools']) if project_data['formatting_tools'] else 'None'}
- **Build Tools**: {', '.join(project_data['build_tools']) if project_data['build_tools'] else 'None'}

## Infrastructure

- **Containerization**: {', '.join(project_data['containerization']) if project_data['containerization'] else 'None'}
- **Orchestration**: {', '.join(project_data['orchestration']) if project_data['orchestration'] else 'None'}
- **Cloud Platforms**: {', '.join(project_data['cloud_platforms']) if project_data['cloud_platforms'] else 'None'}

## Documentation Sources

{chr(10).join(f'- {ds}' for ds in project_data['documentation_sources']) if project_data['documentation_sources'] else '- None'}

---
*This file is automatically generated and updated by the `/init-cursorworkspace` command.*
"""
    
    project_file.write_text(content, encoding='utf-8')
    
    return project_file


def load_project_file(project_root: Optional[str] = None) -> Optional[Dict[str, Any]]:
    """
    Load projectFile.md and extract context.
    
    Args:
        project_root: Project root directory (default: current directory)
        
    Returns:
        Context dictionary or None if file doesn't exist
    """
    if project_root is None:
        project_root = Path.cwd()
    else:
        project_root = Path(project_root).resolve()
    
    project_file = project_root / 'projectFile.md'
    
    if not project_file.exists():
        return None
    
    content = project_file.read_text(encoding='utf-8')
    
    # Extract YAML frontmatter
    if content.startswith('---'):
        parts = content.split('---', 2)
        if len(parts) >= 3:
            yaml_content = parts[1].strip()
            try:
                project_data = yaml.safe_load(yaml_content)
                return project_data
            except yaml.YAMLError as e:
                raise ValueError(f"Invalid YAML in projectFile.md: {e}")
    
    raise ValueError("projectFile.md does not contain valid YAML frontmatter")


def update_project_file(context: Dict[str, Any], project_root: Optional[str] = None) -> Path:
    """
    Update existing projectFile.md with new context, preserving metadata.
    
    Args:
        context: Updated context dictionary
        project_root: Project root directory (default: current directory)
        
    Returns:
        Path to updated projectFile.md
    """
    if project_root is None:
        project_root = Path.cwd()
    else:
        project_root = Path(project_root).resolve()
    
    # Load existing file if it exists
    existing_data = load_project_file(project_root)
    
    if existing_data:
        # Preserve metadata
        metadata = existing_data.get('metadata', {})
        metadata['updated_at'] = datetime.now().isoformat()
        
        # Merge context
        merged_context = existing_data.copy()
        merged_context.update(context)
        merged_context['metadata'] = metadata
        
        # Recreate file with merged data
        return create_project_file(merged_context, project_root)
    else:
        # Create new file
        return create_project_file(context, project_root)


def project_file_exists(project_root: Optional[str] = None) -> bool:
    """
    Check if projectFile.md exists.
    
    Args:
        project_root: Project root directory (default: current directory)
        
    Returns:
        True if file exists, False otherwise
    """
    if project_root is None:
        project_root = Path.cwd()
    else:
        project_root = Path(project_root).resolve()
    
    project_file = project_root / 'projectFile.md'
    return project_file.exists()


def validate_project_file(project_root: Optional[str] = None) -> tuple[bool, list[str]]:
    """
    Validate projectFile.md structure.
    
    Args:
        project_root: Project root directory (default: current directory)
        
    Returns:
        Tuple of (is_valid, list_of_errors)
    """
    errors = []
    
    try:
        data = load_project_file(project_root)
        if data is None:
            return (False, ['projectFile.md does not exist'])
        
        # Check required fields
        required_fields = ['project_name', 'project_type', 'primary_language']
        for field in required_fields:
            if field not in data or not data[field]:
                errors.append(f"Missing required field: {field}")
        
        # Validate types
        if 'frameworks' in data and not isinstance(data['frameworks'], list):
            errors.append("'frameworks' must be a list")
        
        if 'languages' in data and not isinstance(data['languages'], list):
            errors.append("'languages' must be a list")
        
        return (len(errors) == 0, errors)
    
    except Exception as e:
        return (False, [f"Error validating projectFile.md: {str(e)}"])
